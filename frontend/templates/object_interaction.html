<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>Reverie - AIèˆ‡ç‰©å“/åœ°å€äº¤äº’è¦–è¦ºåŒ–</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css">
  <style>
    body {
      font-family: 'å¾®è»Ÿé›…é»‘', 'Microsoft YaHei', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    
    .main-container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      margin: 20px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .chart-container {
      background: white;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      position: relative;
    }
    
    .tab-content {
      padding-top: 20px;
    }
    
    .nav-tabs > li.active > a {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 8px 8px 0 0;
    }
    
    .nav-tabs > li > a {
      border: none;
      border-radius: 8px 8px 0 0;
      margin-right: 5px;
      color: #667eea;
      font-weight: bold;
    }
    
    .controls {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      padding: 15px;
      border-radius: 10px;
      margin: 10px 0;
      text-align: center;
    }
    
    .btn-control {
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 20px;
      padding: 8px 16px;
      margin: 0 5px;
      color: #333;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    
    .btn-control:hover {
      background: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .tooltip {
      position: absolute;
      padding: 12px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 8px;
      font-size: 12px;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .stats-container {
      display: flex;
      justify-content: space-around;
      margin: 20px 0;
    }
    
    .stat-card {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      flex: 1;
      margin: 0 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    
    .stat-number {
      font-size: 24px;
      font-weight: bold;
    }
    
    .stat-label {
      font-size: 14px;
      opacity: 0.9;
    }
  </style>
</head>

<body>
  <div class="main-container">
    <div class="row">
      <div class="col-md-12">
        <a href="/" class="btn btn-primary" style="border-radius: 20px; padding: 10px 20px;">ğŸ  è¿”å›ä¸»é </a>
        <h2 class="text-center" style="color: #667eea; margin: 20px 0; font-weight: bold;">
          ğŸ¤– AI æ™ºèƒ½é«”äº¤äº’åˆ†æå„€è¡¨æ¿
        </h2>
        
        <!-- çµ±è¨ˆå¡ç‰‡ -->
        <div class="stats-container">
          <div class="stat-card">
            <div class="stat-number" id="total-ai-count">0</div>
            <div class="stat-label">AI æ™ºèƒ½é«”</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="total-object-count">0</div>
            <div class="stat-label">äº’å‹•ç‰©å“</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="total-location-count">0</div>
            <div class="stat-label">æ´»å‹•åœ°å€</div>
          </div>
          <div class="stat-card">
            <div class="stat-number" id="total-interaction-count">0</div>
            <div class="stat-label">ç¸½äº¤äº’æ¬¡æ•¸</div>
          </div>
        </div>
        
        <!-- é ç±¤å°èˆª -->
        <ul class="nav nav-tabs" role="tablist">
          <li role="presentation" class="active">
            <a href="#circular-object" aria-controls="circular-object" role="tab" data-toggle="tab">
              ğŸ”§ AI-ç‰©å“äº¤äº’åœ“ç’°åœ–
            </a>
          </li>
          <li role="presentation">
            <a href="#circular-location" aria-controls="circular-location" role="tab" data-toggle="tab">
              ğŸ  AI-åœ°å€äº¤äº’åœ“ç’°åœ–
            </a>
          </li>
          <li role="presentation">
            <a href="#bubble-chart" aria-controls="bubble-chart" role="tab" data-toggle="tab">
              ğŸ’­ äº¤äº’å¼·åº¦æ°£æ³¡åœ–
            </a>
          </li>
          <li role="presentation">
            <a href="#sankey-flow" aria-controls="sankey-flow" role="tab" data-toggle="tab">
              ğŸŒŠ äº¤äº’æµå‘åœ–
            </a>
          </li>
        </ul>
        
        <!-- é ç±¤å…§å®¹ -->
        <div class="tab-content">
          <!-- AIèˆ‡ç‰©å“åœ“ç’°äº¤äº’åœ– -->
          <div role="tabpanel" class="tab-pane active" id="circular-object">
            <div class="controls">
              <button id="object-zoom-in" class="btn btn-control">ğŸ” æ”¾å¤§</button>
              <button id="object-zoom-out" class="btn btn-control">ğŸ” ç¸®å°</button>
              <button id="object-reset" class="btn btn-control">ğŸ¯ é‡ç½®</button>
              <button id="object-animate" class="btn btn-control">âœ¨ å‹•ç•«</button>
            </div>
            <div class="chart-container" id="object-chart" style="height: 700px;"></div>
          </div>
          
          <!-- AIèˆ‡åœ°å€åœ“ç’°äº¤äº’åœ– -->
          <div role="tabpanel" class="tab-pane" id="circular-location">
            <div class="controls">
              <button id="location-zoom-in" class="btn btn-control">ğŸ” æ”¾å¤§</button>
              <button id="location-zoom-out" class="btn btn-control">ğŸ” ç¸®å°</button>
              <button id="location-reset" class="btn btn-control">ğŸ¯ é‡ç½®</button>
              <button id="location-animate" class="btn btn-control">âœ¨ å‹•ç•«</button>
            </div>
            <div class="chart-container" id="location-chart" style="height: 700px;"></div>
          </div>
          
          <!-- æ°£æ³¡åœ– -->
          <div role="tabpanel" class="tab-pane" id="bubble-chart">
            <div class="chart-container" id="bubble-container" style="height: 700px;"></div>
          </div>
          
          <!-- æ¡‘åŸºæµå‘åœ– -->
          <div role="tabpanel" class="tab-pane" id="sankey-flow">
            <div class="chart-container" id="sankey-container" style="height: 700px;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js"></script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  
  <script>
    // å¾å¾Œç«¯å‚³å…¥çš„æ•¸æ“š
    const interactionData = {{ interaction_data | tojson }};
    const personaNames = {{ persona_names | tojson }};
    
    // å…¨å±€è®Šé‡
    let objectSvg, locationSvg, objectZoom, locationZoom;
    let tooltip;
    let animationRunning = false;
    
    // é¡è‰²æ–¹æ¡ˆ
    const colors = {
      ai: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE'],
      object: ['#FFD93D', '#6BCF7F', '#4D96FF', '#FF9F43', '#9C88FF', '#FCA86F', '#5F7ADB', '#52C4B0'],
      location: ['#FF8A80', '#82B1FF', '#B39DDB', '#C5E1A5', '#FFD54F', '#FFAB91', '#80DEEA', '#F8BBD9']
    };
    
    // ç•¶é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Interaction Data:', interactionData);
      console.log('Persona Names:', personaNames);
      
      initializeTooltip();
      updateStatistics();
      createCircularObjectChart();
      bindControlEvents();
      
      // ç¶å®šé ç±¤åˆ‡æ›äº‹ä»¶
      $('.nav-tabs a[data-toggle="tab"]').on('shown.bs.tab', function(e) {
        const target = $(e.target).attr("href");
        console.log('Tab switched to:', target);
        
        // å»¶é²100msç¢ºä¿DOMæ›´æ–°å®Œæˆ
        setTimeout(() => {
          if (target === '#circular-location') {
            createCircularLocationChart();
          } else if (target === '#bubble-chart') {
            createBubbleChart();
          } else if (target === '#sankey-flow') {
            createSankeyChart();
          }
        }, 100);
      });
    });
    
    function initializeTooltip() {
      tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
    }
    
    function updateStatistics() {
      const aiCount = personaNames.length;
      const objectCount = new Set(interactionData.object_interactions.map(d => d.object)).size;
      const locationCount = new Set(interactionData.location_interactions.map(d => d.location)).size;
      const totalInteractions = interactionData.object_interactions.reduce((sum, d) => sum + d.count, 0) +
                               interactionData.location_interactions.reduce((sum, d) => sum + d.count, 0);
      
      document.getElementById('total-ai-count').textContent = aiCount;
      document.getElementById('total-object-count').textContent = objectCount;
      document.getElementById('total-location-count').textContent = locationCount;
      document.getElementById('total-interaction-count').textContent = totalInteractions;
    }
    
    // æ”¹é€²çš„åœ“ç’°åœ– - æ¸›å°‘æ“æ“ 
    function createCircularObjectChart() {
      d3.select("#object-chart").html("");
      
      const width = document.querySelector("#object-chart").clientWidth;
      const height = 700;
      const centerX = width / 2;
      const centerY = height / 2;
      const outerRadius = Math.min(width, height) / 2 - 120; // å¢åŠ é‚Šè·
      const innerRadius = outerRadius - 120; // æ¸›å°‘åœ“ç’°å¯¬åº¦
      
      const svg = d3.select("#object-chart")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
      
      objectSvg = svg;
      
      objectZoom = d3.zoom()
        .scaleExtent([0.3, 5]) // å…è¨±æ›´å¤§çš„ç¸®æ”¾ç¯„åœ
        .on("zoom", function(event) {
          g.attr("transform", event.transform);
        });
      
      svg.call(objectZoom);
      
      const g = svg.append("g");
      
      // æº–å‚™æ•¸æ“š
      const data = interactionData.object_interactions;
      const objects = [...new Set(data.map(d => d.object))];
      
      if (objects.length === 0) {
        g.append("text")
          .attr("x", centerX)
          .attr("y", centerY)
          .attr("text-anchor", "middle")
          .attr("font-size", "18px")
          .attr("fill", "#666")
          .text("æš«ç„¡ç‰©å“äº¤äº’æ•¸æ“š");
        return;
      }
      
      // éæ¿¾ä½é »äº¤äº’ï¼Œæ¸›å°‘è¦–è¦ºæ··äº‚
      const minInteractions = 3;
      const filteredData = data.filter(d => d.count >= minInteractions);
      const filteredObjects = [...new Set(filteredData.map(d => d.object))];
      
      const aiAngleStep = (2 * Math.PI) / personaNames.length;
      const objectAngleStep = (2 * Math.PI) / filteredObjects.length;
      
      // å‰µå»ºAIç¯€é»ï¼ˆå…§åœˆï¼‰
      const aiNodes = personaNames.map((name, i) => ({
        id: name,
        type: 'ai',
        name: name,
        angle: i * aiAngleStep,
        x: centerX + innerRadius * Math.cos(i * aiAngleStep),
        y: centerY + innerRadius * Math.sin(i * aiAngleStep),
        color: colors.ai[i % colors.ai.length]
      }));
      
      // å‰µå»ºç‰©å“ç¯€é»ï¼ˆå¤–åœˆï¼‰- é€²ä¸€æ­¥å¢åŠ åŠå¾‘
      const objectNodes = filteredObjects.map((obj, i) => ({
        id: obj,
        type: 'object',
        name: obj,
        angle: i * objectAngleStep,
        x: centerX + (outerRadius + 40) * Math.cos(i * objectAngleStep), // å†å¢åŠ 20åƒç´ 
        y: centerY + (outerRadius + 40) * Math.sin(i * objectAngleStep),
        color: colors.object[i % colors.object.length]
      }));
      
      // å‰µå»ºé€£æ¥ç·š
      const connections = filteredData.map(d => {
        const aiNode = aiNodes.find(n => n.name === d.agent);
        const objectNode = objectNodes.find(n => n.name === d.object);
        if (!aiNode || !objectNode) return null;
        return {
          source: aiNode,
          target: objectNode,
          count: d.count,
          agent: d.agent,
          object: d.object
        };
      }).filter(d => d !== null);
      
      // ç¹ªè£½é€£æ¥ç·š - æ›´ç´°ï¼Œæ¸›å°‘è¦–è¦ºå¹²æ“¾
      const lines = g.selectAll(".connection-line")
        .data(connections)
        .enter()
        .append("line")
        .attr("class", "connection-line")
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y)
        .attr("stroke", d => d.source.color)
        .attr("stroke-width", d => Math.min(Math.sqrt(d.count) + 1, 5)) // é™åˆ¶æœ€å¤§ç·šå¯¬
        .attr("stroke-opacity", 0.4) // é™ä½é»˜èªé€æ˜åº¦
        .on("mouseover", function(event, d) {
          d3.select(this).attr("stroke-opacity", 0.9).attr("stroke-width", Math.sqrt(d.count) * 2 + 2);
          showTooltip(event, `${d.agent} â†” ${d.object}<br/>äº¤äº’æ¬¡æ•¸: ${d.count}`);
        })
        .on("mouseout", function(event, d) {
          d3.select(this).attr("stroke-opacity", 0.4).attr("stroke-width", Math.min(Math.sqrt(d.count) + 1, 5));
          hideTooltip();
        });
      
      // åªåœ¨é«˜é »äº¤äº’ä¸Šé¡¯ç¤ºæ•¸å­—ï¼Œé¿å…éæ–¼æ“æ“ 
      const lineLabels = g.selectAll(".line-label")
        .data(connections.filter(d => d.count > 5)) // åªé¡¯ç¤ºé«˜é »äº¤äº’çš„æ•¸å­—
        .enter()
        .append("text")
        .attr("class", "line-label")
        .attr("x", d => (d.source.x + d.target.x) / 2)
        .attr("y", d => (d.source.y + d.target.y) / 2)
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", "9px")
        .attr("font-weight", "bold")
        .attr("fill", "#2C3E50")
        .attr("opacity", 0.7)
        .text(d => d.count);
      
      // ç¹ªè£½AIç¯€é» - ç¨å¾®èª¿å°
      const aiGroup = g.selectAll(".ai-node")
        .data(aiNodes)
        .enter()
        .append("g")
        .attr("class", "ai-node")
        .attr("transform", d => `translate(${d.x}, ${d.y})`);
      
      aiGroup.append("circle")
        .attr("r", 24) // ç¨å¾®å¢å¤§AIç¯€é»
        .attr("fill", d => d.color)
        .attr("stroke", "#FFF")
        .attr("stroke-width", 3)
        .on("mouseover", function(event, d) {
          d3.select(this).transition().duration(200).attr("r", 28);
          highlightConnections(d.name, 'ai');
          const connectCount = connections.filter(c => c.agent === d.name).length;
          const totalCount = connections.filter(c => c.agent === d.name).reduce((sum, c) => sum + c.count, 0);
          showTooltip(event, `ğŸ¤– ${d.name}<br/>é€£æ¥ç‰©å“: ${connectCount}<br/>ç¸½äº¤äº’: ${totalCount}`);
        })
        .on("mouseout", function(event, d) {
          d3.select(this).transition().duration(200).attr("r", 24);
          resetHighlight();
          hideTooltip();
        });
      
      aiGroup.append("text")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", "11px")
        .attr("fill", "#FFF")
        .attr("font-weight", "bold")
        .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.7)")
        .text(d => d.name);
      
      // ç¹ªè£½ç‰©å“ç¯€é» - èª¿å°ä¸¦ç°¡åŒ–
      const objectGroup = g.selectAll(".object-node")
        .data(objectNodes)
        .enter()
        .append("g")
        .attr("class", "object-node")
        .attr("transform", d => `translate(${d.x}, ${d.y})`);
      
      objectGroup.append("rect")
        .attr("x", -32)
        .attr("y", -22)
        .attr("width", 64)
        .attr("height", 44)
        .attr("rx", 10)
        .attr("fill", d => d.color)
        .attr("stroke", "#FFF")
        .attr("stroke-width", 3)
        .on("mouseover", function(event, d) {
          d3.select(this).transition().duration(200).attr("width", 72).attr("height", 50).attr("x", -36).attr("y", -25);
          highlightConnections(d.name, 'object');
          const connectCount = connections.filter(c => c.object === d.name).length;
          const totalCount = connections.filter(c => c.object === d.name).reduce((sum, c) => sum + c.count, 0);
          showTooltip(event, `ğŸ”§ ${d.name}<br/>ä½¿ç”¨AI: ${connectCount}<br/>ç¸½äº¤äº’: ${totalCount}`);
        })
        .on("mouseout", function(event, d) {
          d3.select(this).transition().duration(200).attr("width", 64).attr("height", 44).attr("x", -32).attr("y", -22);
          resetHighlight();
          hideTooltip();
        });
      
      objectGroup.append("text")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", "13px")
        .attr("fill", "#FFF")
        .attr("font-weight", "bold")
        .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.7)")
        .text(d => {
          // æ›´æ™ºèƒ½çš„æ–‡å­—è™•ç† - æ ¹æ“šæ–‡å­—é•·åº¦èª¿æ•´é¡¯ç¤º
          if (d.name.length <= 10) {
            return d.name;
          } else if (d.name.length <= 12) {
            return d.name.substring(0, 10) + '..';
          } else {
            return d.name.substring(0, 9) + '...';
          }
        });
      
      // æ·»åŠ æ¨™ç±¤
      g.append("text")
        .attr("x", centerX)
        .attr("y", centerY - innerRadius + 20)
        .attr("text-anchor", "middle")
        .attr("font-size", "14px")
        .attr("font-weight", "bold")
        .attr("fill", "#2C3E50")
        .text("ğŸ¤– AI æ™ºèƒ½é«”");
      
      g.append("text")
        .attr("x", centerX)
        .attr("y", centerY + outerRadius + 110) // é€²ä¸€æ­¥èª¿æ•´æ¨™ç±¤ä½ç½®
        .attr("text-anchor", "middle")
        .attr("font-size", "16px")
        .attr("font-weight", "bold")
        .attr("fill", "#2C3E50")
        .text("ğŸ”§ äº’å‹•ç‰©å“");
      
      // æ·»åŠ éæ¿¾æç¤º
      if (data.length > filteredData.length) {
        g.append("text")
          .attr("x", centerX)
          .attr("y", 30)
          .attr("text-anchor", "middle")
          .attr("font-size", "12px")
          .attr("fill", "#666")
          .text(`é¡¯ç¤º ${minInteractions} æ¬¡ä»¥ä¸Šäº¤äº’ (${filteredData.length}/${data.length})`);
      }
      
      // é«˜äº®é€£æ¥å‡½æ•¸
      function highlightConnections(name, type) {
        lines.style("stroke-opacity", d => {
          if (type === 'ai' && d.agent === name) return 0.9;
          if (type === 'object' && d.object === name) return 0.9;
          return 0.1;
        });
        
        lineLabels.style("opacity", d => {
          if (type === 'ai' && d.agent === name) return 1;
          if (type === 'object' && d.object === name) return 1;
          return 0.2;
        });
      }
      
      function resetHighlight() {
        lines.style("stroke-opacity", 0.4);
        lineLabels.style("opacity", 0.7);
      }
    }
    
    // å…¶ä»–åœ–è¡¨å‰µå»ºå‡½æ•¸
    function createCircularLocationChart() {
      d3.select("#location-chart").html("");
      
      const width = document.querySelector("#location-chart").clientWidth;
      const height = 700;
      const centerX = width / 2;
      const centerY = height / 2;
      const outerRadius = Math.min(width, height) / 2 - 120;
      const innerRadius = outerRadius - 120;
      
      const svg = d3.select("#location-chart")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
      
      locationSvg = svg;
      
      locationZoom = d3.zoom()
        .scaleExtent([0.3, 5])
        .on("zoom", function(event) {
          g.attr("transform", event.transform);
        });
      
      svg.call(locationZoom);
      
      const g = svg.append("g");
      
      // æº–å‚™æ•¸æ“š
      const data = interactionData.location_interactions;
      const locations = [...new Set(data.map(d => d.location))];
      
      if (locations.length === 0) {
        g.append("text")
          .attr("x", centerX)
          .attr("y", centerY)
          .attr("text-anchor", "middle")
          .attr("font-size", "18px")
          .attr("fill", "#666")
          .text("æš«ç„¡åœ°å€äº¤äº’æ•¸æ“š");
        return;
      }
      
      // éæ¿¾ä½é »äº¤äº’
      const minInteractions = 2;
      const filteredData = data.filter(d => d.count >= minInteractions);
      const filteredLocations = [...new Set(filteredData.map(d => d.location))];
      
      const aiAngleStep = (2 * Math.PI) / personaNames.length;
      const locationAngleStep = (2 * Math.PI) / filteredLocations.length;
      
      // å‰µå»ºAIç¯€é»ï¼ˆå…§åœˆï¼‰
      const aiNodes = personaNames.map((name, i) => ({
        id: name,
        type: 'ai',
        name: name,
        angle: i * aiAngleStep,
        x: centerX + innerRadius * Math.cos(i * aiAngleStep),
        y: centerY + innerRadius * Math.sin(i * aiAngleStep),
        color: colors.ai[i % colors.ai.length]
      }));
      
      // å‰µå»ºåœ°å€ç¯€é»ï¼ˆå¤–åœˆï¼‰- åŒæ¨£å¤§å¹…å¢åŠ åˆ†æ•£åº¦
      const locationNodes = filteredLocations.map((loc, i) => ({
        id: loc,
        type: 'location',
        name: loc,
        angle: i * locationAngleStep,
        x: centerX + (outerRadius + 40) * Math.cos(i * locationAngleStep),
        y: centerY + (outerRadius + 40) * Math.sin(i * locationAngleStep),
        color: colors.location[i % colors.location.length]
      }));
      
      // å‰µå»ºé€£æ¥ç·š
      const connections = filteredData.map(d => {
        const aiNode = aiNodes.find(n => n.name === d.agent);
        const locationNode = locationNodes.find(n => n.name === d.location);
        if (!aiNode || !locationNode) return null;
        return {
          source: aiNode,
          target: locationNode,
          count: d.count,
          agent: d.agent,
          location: d.location
        };
      }).filter(d => d !== null);
      
      // ç¹ªè£½èƒŒæ™¯åœ“ç’°
      g.append("circle")
        .attr("cx", centerX)
        .attr("cy", centerY)
        .attr("r", innerRadius - 20)
        .attr("fill", "none")
        .attr("stroke", "#E3F2FD")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,5");
      
      g.append("circle")
        .attr("cx", centerX)
        .attr("cy", centerY)
        .attr("r", outerRadius + 20)
        .attr("fill", "none")
        .attr("stroke", "#FFE0E6")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,5");
      
      // ç¹ªè£½é€£æ¥ç·š
      const lines = g.selectAll(".connection-line")
        .data(connections)
        .enter()
        .append("line")
        .attr("class", "connection-line")
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y)
        .attr("stroke", d => d.source.color)
        .attr("stroke-width", d => Math.min(Math.sqrt(d.count) + 1, 5))
        .attr("stroke-opacity", 0.4)
        .on("mouseover", function(event, d) {
          d3.select(this).attr("stroke-opacity", 0.9).attr("stroke-width", Math.sqrt(d.count) * 2 + 2);
          showTooltip(event, `${d.agent} â†” ${d.location}<br/>æ´»å‹•æ¬¡æ•¸: ${d.count}`);
        })
        .on("mouseout", function(event, d) {
          d3.select(this).attr("stroke-opacity", 0.4).attr("stroke-width", Math.min(Math.sqrt(d.count) + 1, 5));
          hideTooltip();
        });
      
      // ç¹ªè£½é€£æ¥ç·šä¸Šçš„æ•¸å­—
      const lineLabels = g.selectAll(".line-label")
        .data(connections.filter(d => d.count > 3))
        .enter()
        .append("text")
        .attr("class", "line-label")
        .attr("x", d => (d.source.x + d.target.x) / 2)
        .attr("y", d => (d.source.y + d.target.y) / 2)
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", "9px")
        .attr("font-weight", "bold")
        .attr("fill", "#2C3E50")
        .attr("opacity", 0.7)
        .text(d => d.count);
      
      // ç¹ªè£½AIç¯€é»
      const aiGroup = g.selectAll(".ai-node")
        .data(aiNodes)
        .enter()
        .append("g")
        .attr("class", "ai-node")
        .attr("transform", d => `translate(${d.x}, ${d.y})`);
      
      aiGroup.append("circle")
        .attr("r", 20)
        .attr("fill", d => d.color)
        .attr("stroke", "#FFF")
        .attr("stroke-width", 2)
        .on("mouseover", function(event, d) {
          d3.select(this).transition().duration(200).attr("r", 25);
          highlightConnections(d.name, 'ai');
          const connectCount = connections.filter(c => c.agent === d.name).length;
          const totalCount = connections.filter(c => c.agent === d.name).reduce((sum, c) => sum + c.count, 0);
          showTooltip(event, `ğŸ¤– ${d.name}<br/>æ´»å‹•åœ°å€: ${connectCount}<br/>ç¸½æ´»å‹•: ${totalCount}`);
        })
        .on("mouseout", function(event, d) {
          d3.select(this).transition().duration(200).attr("r", 20);
          resetHighlight();
          hideTooltip();
        });
      
      aiGroup.append("text")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", "9px")
        .attr("fill", "#FFF")
        .attr("font-weight", "bold")
        .text(d => d.name);
      
      // ç¹ªè£½åœ°å€ç¯€é» - å…­é‚Šå½¢
      const locationGroup = g.selectAll(".location-node")
        .data(locationNodes)
        .enter()
        .append("g")
        .attr("class", "location-node")
        .attr("transform", d => `translate(${d.x}, ${d.y})`);
      
      locationGroup.append("polygon")
        .attr("points", d => {
          const size = 26; // å†æ¬¡å¢åŠ å…­é‚Šå½¢å¤§å°
          const points = [];
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = size * Math.cos(angle);
            const y = size * Math.sin(angle);
            points.push(`${x},${y}`);
          }
          return points.join(' ');
        })
        .attr("fill", d => d.color)
        .attr("stroke", "#FFF")
        .attr("stroke-width", 3)
        .on("mouseover", function(event, d) {
          d3.select(this).transition().duration(200).attr("points", () => {
            const size = 30;
            const points = [];
            for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI) / 3;
              const x = size * Math.cos(angle);
              const y = size * Math.sin(angle);
              points.push(`${x},${y}`);
            }
            return points.join(' ');
          });
          highlightConnections(d.name, 'location');
          const connectCount = connections.filter(c => c.location === d.name).length;
          const totalCount = connections.filter(c => c.location === d.name).reduce((sum, c) => sum + c.count, 0);
          showTooltip(event, `ğŸ  ${d.name}<br/>æ´»å‹•AI: ${connectCount}<br/>ç¸½æ´»å‹•: ${totalCount}`);
        })
        .on("mouseout", function(event, d) {
          d3.select(this).transition().duration(200).attr("points", () => {
            const size = 26;
            const points = [];
            for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI) / 3;
              const x = size * Math.cos(angle);
              const y = size * Math.sin(angle);
              points.push(`${x},${y}`);
            }
            return points.join(' ');
          });
          resetHighlight();
          hideTooltip();
        });
      
      locationGroup.append("text")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", "11px")
        .attr("fill", "#FFF")
        .attr("font-weight", "bold")
        .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.7)")
        .text(d => {
          // æ›´æ™ºèƒ½çš„æ–‡å­—è™•ç†
          if (d.name.length <= 8) {
            return d.name;
          } else if (d.name.length <= 10) {
            return d.name.substring(0, 8) + '..';
          } else {
            return d.name.substring(0, 7) + '...';
          }
        });
      
      // æ·»åŠ æ¨™ç±¤
      g.append("text")
        .attr("x", centerX)
        .attr("y", centerY - innerRadius + 20)
        .attr("text-anchor", "middle")
        .attr("font-size", "14px")
        .attr("font-weight", "bold")
        .attr("fill", "#2C3E50")
        .text("ğŸ¤– AI æ™ºèƒ½é«”");
      
      g.append("text")
        .attr("x", centerX)
        .attr("y", centerY + outerRadius + 30)
        .attr("text-anchor", "middle")
        .attr("font-size", "14px")
        .attr("font-weight", "bold")
        .attr("fill", "#2C3E50")
        .text("ğŸ  æ´»å‹•åœ°å€");
      
      // æ·»åŠ éæ¿¾æç¤º
      if (data.length > filteredData.length) {
        g.append("text")
          .attr("x", centerX)
          .attr("y", 30)
          .attr("text-anchor", "middle")
          .attr("font-size", "12px")
          .attr("fill", "#666")
          .text(`é¡¯ç¤º ${minInteractions} æ¬¡ä»¥ä¸Šæ´»å‹• (${filteredData.length}/${data.length})`);
      }
      
      // é«˜äº®é€£æ¥å‡½æ•¸
      function highlightConnections(name, type) {
        lines.style("stroke-opacity", d => {
          if (type === 'ai' && d.agent === name) return 0.9;
          if (type === 'location' && d.location === name) return 0.9;
          return 0.1;
        });
        
        lineLabels.style("opacity", d => {
          if (type === 'ai' && d.agent === name) return 1;
          if (type === 'location' && d.location === name) return 1;
          return 0.2;
        });
      }
      
      function resetHighlight() {
        lines.style("stroke-opacity", 0.4);
        lineLabels.style("opacity", 0.7);
      }
    }
    
    function createBubbleChart() {
      d3.select("#bubble-container").html("");
      
      const width = document.querySelector("#bubble-container").clientWidth;
      const height = 700;
      
      const svg = d3.select("#bubble-container")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
      
      // æº–å‚™æ°£æ³¡æ•¸æ“š
      const bubbleData = [];
      
      // æ·»åŠ AIæ°£æ³¡
      personaNames.forEach((ai, i) => {
        const objectInteractions = interactionData.object_interactions.filter(d => d.agent === ai);
        const locationInteractions = interactionData.location_interactions.filter(d => d.agent === ai);
        const totalInteractions = objectInteractions.reduce((sum, d) => sum + d.count, 0) + 
                                 locationInteractions.reduce((sum, d) => sum + d.count, 0);
        
        if (totalInteractions > 0) {
          bubbleData.push({
            id: ai,
            type: 'ai',
            name: ai,
            value: totalInteractions,
            details: {
              objects: objectInteractions.length,
              locations: locationInteractions.length,
              total: totalInteractions
            },
            color: colors.ai[i % colors.ai.length]
          });
        }
      });
      
      if (bubbleData.length === 0) {
        svg.append("text")
          .attr("x", width / 2)
          .attr("y", height / 2)
          .attr("text-anchor", "middle")
          .attr("font-size", "18px")
          .attr("fill", "#666")
          .text("æš«ç„¡è¶³å¤ æ•¸æ“šç”Ÿæˆæ°£æ³¡åœ–");
        return;
      }
      
      // å‰µå»ºæ°£æ³¡åœ–å¸ƒå±€
      const simulation = d3.forceSimulation(bubbleData)
        .force("charge", d3.forceManyBody().strength(-100))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(d => Math.sqrt(d.value) * 2 + 10));
      
      // å‰µå»ºæ°£æ³¡
      const bubbles = svg.selectAll(".bubble")
        .data(bubbleData)
        .enter()
        .append("g")
        .attr("class", "bubble");
      
      bubbles.append("circle")
        .attr("r", d => Math.sqrt(d.value) * 2 + 10)
        .attr("fill", d => d.color)
        .attr("stroke", "#FFF")
        .attr("stroke-width", 2)
        .attr("opacity", 0.8);
      
      bubbles.append("text")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", "10px")
        .attr("font-weight", "bold")
        .attr("fill", "#FFF")
        .text(d => d.name);
      
      // æ›´æ–°ä½ç½®
      simulation.on("tick", () => {
        bubbles.attr("transform", d => `translate(${d.x}, ${d.y})`);
      });
      
      // æ·»åŠ æ¨™é¡Œ
      svg.append("text")
        .attr("x", width / 2)
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .attr("fill", "#2C3E50")
        .text("ğŸ’­ AI äº¤äº’å¼·åº¦æ°£æ³¡åœ–");
    }
    
    function createSankeyChart() {
      d3.select("#sankey-container").html("");
      
      const width = document.querySelector("#sankey-container").clientWidth;
      const height = 700;
      
      const svg = d3.select("#sankey-container")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
      
      svg.append("text")
        .attr("x", width / 2)
        .attr("y", height / 2)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .attr("fill", "#2C3E50")
        .text("ğŸŒŠ äº¤äº’æµå‘åœ– (é–‹ç™¼ä¸­)");
    }
    
    // è¼”åŠ©å‡½æ•¸
    function showTooltip(event, content) {
      tooltip.transition()
        .duration(200)
        .style("opacity", .9);
      tooltip.html(content)
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY - 28) + "px");
    }
    
    function hideTooltip() {
      tooltip.transition()
        .duration(500)
        .style("opacity", 0);
    }
    
    function getIcon(type) {
      switch(type) {
        case 'ai': return 'ğŸ¤–';
        case 'object': return 'ğŸ”§';
        case 'location': return 'ğŸ ';
        default: return 'â€¢';
      }
    }
    
    // ç¶å®šæ§åˆ¶æŒ‰éˆ•äº‹ä»¶
    function bindControlEvents() {
      // ç‰©å“åœ–æ§åˆ¶
      document.getElementById('object-zoom-in').addEventListener('click', function() {
        if (objectSvg && objectZoom) {
          objectSvg.transition().duration(300).call(objectZoom.scaleBy, 1.5);
        }
      });
      
      document.getElementById('object-zoom-out').addEventListener('click', function() {
        if (objectSvg && objectZoom) {
          objectSvg.transition().duration(300).call(objectZoom.scaleBy, 0.67);
        }
      });
      
      document.getElementById('object-reset').addEventListener('click', function() {
        if (objectSvg && objectZoom) {
          objectSvg.transition().duration(750).call(objectZoom.transform, d3.zoomIdentity);
        }
      });
      
      document.getElementById('object-animate').addEventListener('click', function() {
        if (!animationRunning) {
          animateConnections('#object-chart');
        }
      });
      
      // åœ°å€åœ–æ§åˆ¶
      document.getElementById('location-zoom-in').addEventListener('click', function() {
        if (locationSvg && locationZoom) {
          locationSvg.transition().duration(300).call(locationZoom.scaleBy, 1.5);
        }
      });
      
      document.getElementById('location-zoom-out').addEventListener('click', function() {
        if (locationSvg && locationZoom) {
          locationSvg.transition().duration(300).call(locationZoom.scaleBy, 0.67);
        }
      });
      
      document.getElementById('location-reset').addEventListener('click', function() {
        if (locationSvg && locationZoom) {
          locationSvg.transition().duration(750).call(locationZoom.transform, d3.zoomIdentity);
        }
      });
      
      document.getElementById('location-animate').addEventListener('click', function() {
        if (!animationRunning) {
          animateConnections('#location-chart');
        }
      });
    }
    
    // å‹•ç•«æ•ˆæœ
    function animateConnections(chartSelector) {
      animationRunning = true;
      const lines = d3.select(chartSelector).selectAll('.connection-line');
      const labels = d3.select(chartSelector).selectAll('.line-label');
      
      lines.each(function(d, i) {
        d3.select(this)
          .transition()
          .delay(i * 50)
          .duration(800)
          .attr('stroke-width', function() {
            const currentWidth = parseFloat(d3.select(this).attr('stroke-width'));
            return currentWidth * 2;
          })
          .attr('stroke-opacity', 0.9)
          .transition()
          .duration(400)
          .attr('stroke-width', function() {
            const currentWidth = parseFloat(d3.select(this).attr('stroke-width'));
            return currentWidth / 2;
          })
          .attr('stroke-opacity', 0.4);
      });
      
      labels.each(function(d, i) {
        d3.select(this)
          .transition()
          .delay(i * 50)
          .duration(800)
          .attr('font-size', '12px')
          .attr('opacity', 1)
          .transition()
          .duration(400)
          .attr('font-size', '9px')
          .attr('opacity', 0.7);
      });
      
      setTimeout(() => {
        animationRunning = false;
      }, 2000);
    }
  </script>
</body>
</html>